# Vulnerability Rules

Pattern database for Solana smart contract security analysis. Each rule defines a vulnerability class with severity, detection hints, and remediation guidance.

Rules are referenced by skills via pattern ID. The `detection_hint` field tells the analyzing agent exactly what syntax or constraint pattern to search for in the target program.

---

## VULN-001: Missing Signer Check

| Field | Value |
|-------|-------|
| **ID** | `missing-signer-check` |
| **Severity** | Critical |
| **Pattern Type** | MissingSignerCheck |

**Description:**
Instruction does not verify that the authority account has signed the transaction. Any account can be passed as authority, allowing unauthorized state modification including fund withdrawal, config changes, and ownership transfer.

**Detection Hint:**
Check for `Signer<'info>` constraint on authority accounts in `#[derive(Accounts)]`. If an account named `authority`, `admin`, `owner`, or `payer` is typed as `AccountInfo<'info>` instead of `Signer<'info>`, this rule is violated.

**Vulnerable:**
```rust
pub authority: AccountInfo<'info>,
```

**Secure:**
```rust
pub authority: Signer<'info>,
#[account(mut, has_one = authority)]
pub config: Account<'info, Config>,
```

**Audit References:**
- OtterSec: "Admin functions callable by any signer due to missing authority validation"
- Sec3: "Multisig threshold check uses >= instead of > allowing single-signer bypass"

---

## VULN-002: Unchecked Arithmetic

| Field | Value |
|-------|-------|
| **ID** | `unchecked-arithmetic` |
| **Severity** | High |
| **Pattern Type** | UncheckedArithmetic |

**Description:**
Arithmetic operation may overflow or underflow without checked math. On large values this could result in incorrect token amounts, share calculations, fee computations, or balance tracking. Solana programs run in BPF which wraps on overflow by default.

**Detection Hint:**
Look for `+`, `-`, `*` operators on `u64`, `u128`, or `i64` values without `checked_add`, `checked_sub`, `checked_mul`. Pay special attention to calculations involving user-supplied amounts, balances, shares, fees, and timestamps.

**Vulnerable:**
```rust
let shares = deposit_amount * total_shares / total_deposits;
```

**Secure:**
```rust
let shares = deposit_amount
    .checked_mul(total_shares)
    .ok_or(ErrorCode::Overflow)?
    .checked_div(total_deposits)
    .ok_or(ErrorCode::DivisionByZero)?;
```

**Audit References:**
- Sec3: "Token amount calculation overflows on large deposits"

---

## VULN-003: Unvalidated PDA

| Field | Value |
|-------|-------|
| **ID** | `unvalidated-pda` |
| **Severity** | Critical |
| **Pattern Type** | UnvalidatedPda |

**Description:**
PDA derivation uses attacker-controlled seeds without validation. An attacker could derive a different PDA than intended, accessing or overwriting arbitrary program state. This is especially dangerous when the PDA controls funds or protocol configuration.

**Detection Hint:**
Verify `seeds` constraints in `#[account]` and check for bump validation. Look for `Pubkey::find_program_address` calls where seeds include user-supplied strings or unbounded byte arrays. Ensure `bump = account.bump` references stored canonical bump.

**Vulnerable:**
```rust
seeds = [b"vault", user_input.as_bytes()]
```

**Secure:**
```rust
#[account(
    seeds = [b"vault", owner.key().as_ref()],
    bump = vault.bump,
)]
pub vault: Account<'info, Vault>,
```

**Audit References:**
- Neodyme: "Vault PDA seeds include user-supplied string without length validation"

---

## VULN-004: Insecure CPI

| Field | Value |
|-------|-------|
| **ID** | `insecure-cpi` |
| **Severity** | Critical |
| **Pattern Type** | InsecureCpi |

**Description:**
Cross-program invocation does not verify the target program ID. An attacker could substitute a malicious program that mimics the expected interface but executes arbitrary logic, potentially stealing funds or corrupting state.

**Detection Hint:**
Ensure CPI calls use `Program<'info, T>` typed accounts instead of raw `AccountInfo`. Check that `invoke` and `invoke_signed` calls reference a validated program account. Look for `UncheckedAccount` used as a CPI target.

**Vulnerable:**
```rust
pub token_program: AccountInfo<'info>,
```

**Secure:**
```rust
pub token_program: Program<'info, Token>,
```

**Audit References:**
- OtterSec: "Token program invocation uses unchecked AccountInfo instead of typed Program"

---

## VULN-005: Account Deserialization

| Field | Value |
|-------|-------|
| **ID** | `account-deserialization` |
| **Severity** | High |
| **Pattern Type** | AccountDeserialization |

**Description:**
Account data deserialization does not verify discriminator or owner. If the account type is not validated, an attacker could pass a different account type whose data layout partially overlaps, causing the program to read incorrect values.

**Detection Hint:**
Use `Account<'info, T>` instead of `AccountInfo` for typed deserialization. `Account<>` verifies the 8-byte Anchor discriminator automatically. Check for manual `try_from_slice` calls without discriminator validation.

**Vulnerable:**
```rust
pub user_account: AccountInfo<'info>,
let data = UserAccount::try_from_slice(&user_account.data.borrow())?;
```

**Secure:**
```rust
pub user_account: Account<'info, UserAccount>,
```

---

## VULN-006: Rent Exemption

| Field | Value |
|-------|-------|
| **ID** | `rent-exemption` |
| **Severity** | Medium |
| **Pattern Type** | RentExemption |

**Description:**
Account may not be rent-exempt after initialization or reallocation. Non-rent-exempt accounts are eligible for garbage collection by the runtime, which would destroy program state.

**Detection Hint:**
Verify `init` constraint includes correct space calculation using `8 + T::INIT_SPACE`. For manual account creation, check that `Rent::get()?.minimum_balance(space)` is used. After `realloc`, verify rent threshold is still met.

---

## VULN-007: Close Account Drain

| Field | Value |
|-------|-------|
| **ID** | `close-account-drain` |
| **Severity** | High |
| **Pattern Type** | CloseAccount |

**Description:**
Close account instruction does not properly drain lamports and zero data. Stale data could be read by subsequent transactions, or the account address could be reoccupied with new data that is misinterpreted as the old type.

**Detection Hint:**
Check `close = target` constraint or manual lamport transfer and data zeroing. Verify close instructions have authority validation. Anchor's `close` constraint handles drain and zeroing automatically.

**Vulnerable:**
```rust
**target.try_borrow_mut_lamports()? = 0;
// data not zeroed
```

**Secure:**
```rust
#[account(mut, close = destination, has_one = authority)]
pub target: Account<'info, SomeAccount>,
```

**Audit References:**
- OtterSec: "Account close does not zero data, leaving stale data readable"

---

## VULN-008: Type Cosplay

| Field | Value |
|-------|-------|
| **ID** | `type-cosplay` |
| **Severity** | Critical |
| **Pattern Type** | TypeCosplay |

**Description:**
Account can be substituted with a different account type due to missing discriminator check. If two account types have overlapping byte layouts, an attacker could pass type A where type B is expected, causing the program to misinterpret field values.

**Detection Hint:**
Ensure all accounts use Anchor discriminators via `Account<>` wrapper. Programs using raw deserialization without checking the 8-byte discriminator are vulnerable.

---

## VULN-009: Reinitialization Attack

| Field | Value |
|-------|-------|
| **ID** | `reinitialization-attack` |
| **Severity** | Critical |
| **Pattern Type** | ReinitiallizationAttack |

**Description:**
Account can be re-initialized by calling the init instruction multiple times. An attacker could reset protocol state, overwrite ownership, or drain accumulated funds by re-initializing an account with their own authority.

**Detection Hint:**
Use `init` with care â€” it requires the account to not exist. `init_if_needed` allows re-entry and requires additional guards. Check for `is_initialized` flag patterns.

---

## VULN-010: Owner Check

| Field | Value |
|-------|-------|
| **ID** | `owner-check` |
| **Severity** | High |
| **Pattern Type** | OwnerCheck |

**Description:**
Account owner is not validated, allowing cross-program account injection. An attacker could create an account in a different program with crafted data matching the expected layout, then pass it to this program.

**Detection Hint:**
Verify `owner` field matches expected program ID in constraints. Anchor's `Account<>` wrapper validates owner automatically. Check manual owner comparisons for correctness.

---

## Scoring Model

The `calculate_risk_score` function computes a security score from findings:

```
score = 100
for each finding:
    if severity == Critical: score -= 25
    if severity == High:     score -= 15
    if severity == Medium:   score -= 8
    if severity == Info:     score -= 3
score = max(score, 0)
```

A program with no findings scores 100. Two critical findings and one high finding: 100 - 50 - 15 = 35.
